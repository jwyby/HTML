<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D ç²’å­äº¤äº’ç³»ç»Ÿ Pro</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Font Awesome 6 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Inter', sans-serif; }
        canvas { display: block; outline: none; }
        
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        /* æ»‘å—æ ·å¼ä¼˜åŒ– */
        input[type="range"] {
            -webkit-appearance: none;
            background: transparent;
            height: 20px;
            margin: 0;
            vertical-align: middle;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            margin-top: -5px;
            box-shadow: 0 0 5px rgba(255,255,255,0.5);
            transition: transform 0.1s;
        }
        input[type="range"]:active::-webkit-slider-thumb {
            transform: scale(1.2);
        }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255,255,255,0.15);
            border-radius: 2px;
        }

        /* é¢œè‰²é€‰æ‹©å™¨ */
        .color-picker-wrapper {
            position: relative;
            overflow: hidden;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .color-picker-wrapper input[type="color"] {
            position: absolute;
            top: -50%; left: -50%;
            width: 200%; height: 200%;
            padding: 0; margin: 0;
            cursor: pointer;
            opacity: 0;
        }

        .mirror-x { transform: scaleX(-1); }
        #dropZone.active { display: flex; }
        
        /* å¼€å…³æŒ‰é’®æ¿€æ´»æ ·å¼ */
        .toggle-active {
            background-color: rgba(6, 182, 212, 0.2);
            border-color: rgba(6, 182, 212, 0.5);
            color: #22d3ee;
        }
        .toggle-inactive {
            background-color: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.1);
            color: #9ca3af;
        }
        
        .storage-btn.active {
            background-color: rgba(34, 211, 238, 0.3);
            border-color: #22d3ee;
            color: white;
        }
    </style>
</head>
<body class="text-white select-none">

    <video id="videoInput" class="hidden" playsinline></video>

    <div id="dropZone" class="hidden absolute inset-0 z-50 items-center justify-center bg-black/80 border-4 border-dashed border-green-500/50 backdrop-blur-sm pointer-events-none transition-all duration-300">
        <div class="text-center animate-bounce">
            <i class="fa-solid fa-file-image text-5xl text-green-400 mb-3"></i>
            <h2 class="text-xl font-bold text-green-400">é‡Šæ”¾å›¾ç‰‡</h2>
        </div>
    </div>

    <!-- UI å¼€å…³ -->
    <button id="uiToggleBtn" class="fixed top-3 right-3 z-50 w-10 h-10 bg-gray-800/60 hover:bg-white/20 backdrop-blur border border-white/20 rounded-full flex items-center justify-center text-white transition-all active:scale-95 shadow-lg">
        <i class="fa-solid fa-eye" id="uiToggleIcon"></i>
    </button>

    <div id="mainUiLayer" class="absolute inset-0 pointer-events-none transition-opacity duration-300 z-10">
        
        <!-- å·¦ä¸Šè§’ä¿¡æ¯ -->
        <div class="absolute top-2 left-2 sm:top-4 sm:left-4 pointer-events-auto flex flex-col gap-2 w-56 sm:w-auto">
            <div class="bg-gray-900/70 backdrop-blur-md border border-white/10 rounded-xl p-3 shadow-xl">
                <h1 class="text-sm font-bold flex items-center gap-1.5 bg-gradient-to-r from-cyan-400 to-purple-400 bg-clip-text text-transparent">
                    <i class="fa-solid fa-microchip text-cyan-400 text-xs"></i>
                    <span>ç²’å­ç³»ç»Ÿ Pro</span>
                </h1>
                
                <div class="flex items-center gap-2 mt-1.5 text-[10px] font-mono text-gray-400">
                    <span id="fpsStat">60 FPS</span>
                    <span class="w-0.5 h-0.5 rounded-full bg-gray-600"></span>
                    <span id="particleCount">60k Pts</span>
                </div>
                
                <!-- æ‰‹åŠ¿æ¨¡å¼çŠ¶æ€æ˜¾ç¤º -->
                <div id="gestureStatusPanel" class="hidden mt-2 pt-2 border-t border-white/10">
                    <div class="text-[10px] text-cyan-300 font-bold mb-1">å‚¨è—å¼æ‰‹åŠ¿æ¨¡å¼</div>
                    <div class="text-[9px] text-gray-300 grid grid-cols-2 gap-1">
                        <div>ğŸ‘‰ å³æ‰‹: <span id="rightHandStatus">ç¼©æ”¾</span></div>
                        <div>ğŸ‘ˆ å·¦æ‰‹: <span id="leftHandStatus">...</span></div>
                    </div>
                </div>
            </div>

            <div class="flex items-start gap-2">
                <button id="toggleCamBtn" class="bg-gray-900/70 hover:bg-white/10 backdrop-blur-md border border-white/10 px-2.5 py-1.5 rounded-lg text-[10px] transition flex items-center gap-1.5 shadow-lg active:scale-95 text-gray-200">
                    <i class="fa-solid fa-camera"></i> <span>AI æ‰‹åŠ¿</span>
                </button>
                <div id="camContainer" class="hidden w-24 h-18 bg-black/90 backdrop-blur-md rounded-lg overflow-hidden border border-cyan-500/30 relative shadow-xl">
                    <canvas id="camOutput" class="w-full h-full object-cover mirror-x"></canvas>
                </div>
            </div>
        </div>

        <!-- åº•éƒ¨æ§åˆ¶é¢æ¿ -->
        <div class="absolute bottom-8 left-1/2 -translate-x-1/2 w-[95%] max-w-[340px] sm:bottom-4 sm:right-4 sm:left-auto sm:translate-x-0 pointer-events-auto">
            <div class="bg-gray-900/85 backdrop-blur-xl border border-white/10 rounded-2xl max-h-[50vh] sm:max-h-[85vh] flex flex-col shadow-2xl transition-all">
                
                <!-- é€‰é¡¹å¡ -->
                <div class="flex border-b border-white/5 shrink-0">
                    <button class="flex-1 py-3 text-xs font-bold hover:bg-white/5 transition text-cyan-400 border-b-2 border-cyan-400 focus:outline-none" id="tab-shapes">
                        <i class="fa-solid fa-layer-group mr-1"></i>å›¾å±‚
                    </button>
                    <button class="flex-1 py-3 text-xs font-bold hover:bg-white/5 transition text-gray-500 border-b-2 border-transparent focus:outline-none" id="tab-storage">
                        <i class="fa-solid fa-box-archive mr-1"></i>å‚¨è—
                    </button>
                    <button class="flex-1 py-3 text-xs font-bold hover:bg-white/5 transition text-gray-500 border-b-2 border-transparent focus:outline-none" id="tab-settings">
                        <i class="fa-solid fa-sliders mr-1"></i>è®¾ç½®
                    </button>
                </div>

                <!-- 1. å›¾å±‚å†…å®¹ -->
                <div id="panel-shapes" class="flex-1 overflow-y-auto p-3 no-scrollbar">
                    <div class="grid grid-cols-5 gap-2 mb-4">
                        <button class="add-shape-btn bg-white/5 hover:bg-cyan-500/20 border border-white/5 p-2 rounded-lg flex flex-col items-center transition active:scale-95" data-type="sphere"><span class="text-xl">ğŸ”®</span></button>
                        <button class="add-shape-btn bg-white/5 hover:bg-cyan-500/20 border border-white/5 p-2 rounded-lg flex flex-col items-center transition active:scale-95" data-type="heart"><span class="text-xl">â¤ï¸</span></button>
                        <button class="add-shape-btn bg-white/5 hover:bg-cyan-500/20 border border-white/5 p-2 rounded-lg flex flex-col items-center transition active:scale-95" data-type="terrain"><span class="text-xl">ğŸ”ï¸</span></button>
                        <button class="add-shape-btn bg-white/5 hover:bg-cyan-500/20 border border-white/5 p-2 rounded-lg flex flex-col items-center transition active:scale-95" data-type="saturn"><span class="text-xl">ğŸª</span></button>
                        <button class="add-shape-btn bg-white/5 hover:bg-cyan-500/20 border border-white/5 p-2 rounded-lg flex flex-col items-center transition active:scale-95" data-type="text"><span class="text-xl">ğŸ”¤</span></button>
                    </div>
                    <div class="space-y-3" id="layersList"></div>
                    <div class="h-2"></div>
                </div>

                <!-- 2. å‚¨è—å™¨å†…å®¹ -->
                <div id="panel-storage" class="hidden flex-1 overflow-y-auto p-4 space-y-4 no-scrollbar">
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-xs text-gray-300 font-bold">æ‰‹åŠ¿æ¨¡å¼å¼€å…³</span>
                        <label class="inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="storageModeToggle" class="sr-only peer">
                            <div class="relative w-9 h-5 bg-gray-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-cyan-500"></div>
                        </label>
                    </div>
                    <div class="text-[10px] text-gray-400 mb-4 bg-white/5 p-2 rounded">
                        <i class="fa-solid fa-circle-info mr-1"></i> å¼€å¯åï¼šå·¦æ‰‹1-5æŒ‡åˆ‡æ¢å‚¨è—å™¨ï¼Œæ— æ‰‹åŠ¿æ˜¾ç¤º0å·èƒŒæ™¯ï¼›å³æ‰‹å¼ åˆæ§åˆ¶ç¼©æ”¾ã€‚0å·èƒŒæ™¯å§‹ç»ˆå­˜åœ¨ã€‚
                    </div>

                    <div class="space-y-3">
                        <div class="text-xs text-gray-400 font-bold">å‚¨è—å™¨ç®¡ç† (ç‚¹å‡»åŠ è½½ / é•¿æŒ‰ä¿å­˜)</div>
                        <!-- 0å·èƒŒæ™¯ -->
                        <div class="flex items-center gap-2">
                            <span class="text-xs font-mono w-4 text-gray-500">0</span>
                            <button class="storage-btn flex-1 py-2 bg-white/5 border border-white/10 rounded hover:bg-white/10 text-xs transition relative group" onclick="loadStorage(0)">
                                èƒŒæ™¯å±‚ (Default)
                                <div class="absolute right-2 top-1/2 -translate-y-1/2 opacity-0 group-hover:opacity-100">
                                    <i class="fa-solid fa-play text-[10px]"></i>
                                </div>
                            </button>
                            <button class="w-8 h-8 flex items-center justify-center bg-white/5 hover:bg-cyan-500/20 rounded border border-white/10 text-xs text-gray-400 hover:text-cyan-400 transition" onclick="saveStorage(0)" title="ä¿å­˜å½“å‰åˆ°Slot 0">
                                <i class="fa-solid fa-floppy-disk"></i>
                            </button>
                        </div>
                        
                        <!-- 1-5å· -->
                        <div id="storageSlotsContainer" class="space-y-2">
                            <!-- JS ç”Ÿæˆ -->
                        </div>
                    </div>
                </div>

                <!-- 3. è®¾ç½®å†…å®¹ -->
                <div id="panel-settings" class="hidden flex-1 overflow-y-auto p-4 space-y-4 no-scrollbar">
                    <div>
                        <div class="flex justify-between text-xs mb-2 text-gray-400 font-bold">æ ‡å‡†æ‰‹åŠ¿é…ç½®</div>
                        <div class="grid grid-cols-3 gap-2">
                            <button id="gestureScaleBtn" class="toggle-active border p-2 rounded-lg flex flex-col items-center gap-1 transition active:scale-95"><i class="fa-solid fa-maximize text-sm"></i><span class="text-[10px]">ç¼©æ”¾</span></button>
                            <button id="gestureRotateBtn" class="toggle-active border p-2 rounded-lg flex flex-col items-center gap-1 transition active:scale-95"><i class="fa-solid fa-arrows-rotate text-sm"></i><span class="text-[10px]">æ—‹è½¬</span></button>
                            <button id="gestureFlattenBtn" class="toggle-active border p-2 rounded-lg flex flex-col items-center gap-1 transition active:scale-95"><i class="fa-solid fa-down-left-and-up-right-to-center text-sm"></i><span class="text-[10px]">å‹å¹³</span></button>
                        </div>
                    </div>
                     <div>
                        <div class="flex justify-between text-xs mb-1"><span class="text-gray-400">äº¤äº’åŠ›åº¦</span><span id="forceVal" class="font-mono text-cyan-400">1.0</span></div>
                        <input type="range" id="forceRange" min="0.1" max="3.0" step="0.1" value="1.0" class="w-full">
                    </div>
                    <div class="pt-2 border-t border-white/10 space-y-2">
                        <button id="toggleRotateBtn" class="w-full py-2 bg-white/5 hover:bg-white/10 text-cyan-400 text-xs font-bold rounded-lg transition border border-white/10 active:scale-95 flex items-center justify-center gap-2"><i class="fa-solid fa-sync fa-spin"></i> <span>æš‚åœåœºæ™¯è‡ªè½¬</span></button>
                        <div class="flex gap-2">
                            <button id="resetViewBtn" class="flex-1 py-2 bg-white/5 hover:bg-white/10 text-gray-300 text-xs font-bold rounded-lg transition border border-white/10 active:scale-95"><i class="fa-solid fa-compress"></i> é‡ç½®</button>
                            <button id="clearAllBtn" class="flex-1 py-2 bg-red-500/10 hover:bg-red-500/20 text-red-400 text-xs font-bold rounded-lg transition border border-red-500/20 active:scale-95"><i class="fa-solid fa-trash-can"></i> æ¸…ç©º</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- æ–‡å­—è¾“å…¥ -->
    <div id="textModal" class="hidden fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-6">
        <div class="bg-gray-900 border border-white/20 p-5 rounded-xl w-full max-w-[300px] space-y-4 shadow-2xl">
            <h3 class="text-sm font-bold text-white"><i class="fa-solid fa-keyboard text-cyan-400 mr-2"></i>è¾“å…¥æ–‡å­—</h3>
            <input type="text" id="modalTextInput" class="w-full bg-black/40 border border-white/20 rounded-lg p-3 text-sm text-white outline-none focus:border-cyan-500" placeholder="Type something..." maxlength="8">
            <div class="flex gap-2 justify-end">
                <button id="cancelTextBtn" class="px-4 py-2 text-xs text-gray-400">å–æ¶ˆ</button>
                <button id="confirmTextBtn" class="px-4 py-2 bg-cyan-600 rounded text-xs text-white shadow-lg shadow-cyan-500/20">ç”Ÿæˆ</button>
            </div>
        </div>
    </div>

    <script>
        // --- æ ¸å¿ƒçŠ¶æ€ ---
        const CONFIG = { maxParticles: 60000, baseSize: 1.5, canvasW: 800, canvasH: 800 };
        const STATE = {
            layers: [],
            isCamActive: false,
            autoRotate: true,
            gestures: { scale: true, rotate: true, flatten: true }, 
            handData: { mode: 'none', pinchDist: 0, x: 0, y: 0, active: false, rightFingers: 0, leftPinch: 0 },
            
            // å‚¨è—å™¨ç›¸å…³
            storageMode: false, 
            storages: {},       
            activeStorageIdx: 0 
        };

        // UI åˆ‡æ¢
        const uiToggleBtn = document.getElementById('uiToggleBtn'), mainUiLayer = document.getElementById('mainUiLayer'), uiToggleIcon = document.getElementById('uiToggleIcon');
        let isUiVisible = true;
        uiToggleBtn.addEventListener('click', () => {
            isUiVisible = !isUiVisible;
            if (isUiVisible) {
                mainUiLayer.classList.remove('opacity-0', 'pointer-events-none');
                document.querySelectorAll('#mainUiLayer > div').forEach(el => { el.classList.remove('pointer-events-none'); el.classList.add('pointer-events-auto'); });
                uiToggleIcon.className = "fa-solid fa-eye";
                uiToggleBtn.classList.add('bg-gray-800/60'); uiToggleBtn.classList.remove('bg-white/10');
            } else {
                mainUiLayer.classList.add('opacity-0');
                document.querySelectorAll('#mainUiLayer > div').forEach(el => { el.classList.remove('pointer-events-auto'); el.classList.add('pointer-events-none'); });
                uiToggleIcon.className = "fa-solid fa-eye-slash";
                uiToggleBtn.classList.remove('bg-gray-800/60'); uiToggleBtn.classList.add('bg-white/10');
            }
        });

        // Tab åˆ‡æ¢é€»è¾‘
        const tabs = ['tab-shapes', 'tab-storage', 'tab-settings'];
        const panels = ['panel-shapes', 'panel-storage', 'panel-settings'];
        tabs.forEach((tabId, idx) => {
            document.getElementById(tabId).addEventListener('click', () => {
                tabs.forEach((t, i) => {
                    const btn = document.getElementById(t);
                    const pnl = document.getElementById(panels[i]);
                    if (i === idx) {
                        btn.classList.add('text-cyan-400', 'border-cyan-400'); btn.classList.remove('text-gray-500', 'border-transparent');
                        pnl.classList.remove('hidden');
                    } else {
                        btn.classList.remove('text-cyan-400', 'border-cyan-400'); btn.classList.add('text-gray-500', 'border-transparent');
                        pnl.classList.add('hidden');
                    }
                });
            });
        });

        // --- Three.js & ç²’å­é€»è¾‘ ---
        let scene, camera, renderer, particles, geometry, controls;
        let positions, colors, sizes, targetPositions, targetColors, targetSizes; // å¢åŠ  sizes
        let mouse = new THREE.Vector2(999, 999), isMouseDown = false, isDragging = false;

        function initThree() {
            scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x050505, 0.001);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000); camera.position.z = 200;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.dampingFactor = 0.05;
            controls.autoRotate = true; controls.autoRotateSpeed = 0.8; controls.enablePan = false;
            controls.addEventListener('start', () => isDragging = true);
            controls.addEventListener('end', () => isDragging = false);

            const count = CONFIG.maxParticles;
            positions = new Float32Array(count * 3); colors = new Float32Array(count * 3); sizes = new Float32Array(count);
            targetPositions = new Float32Array(count * 3); targetColors = new Float32Array(count * 3); targetSizes = new Float32Array(count);

            for(let i=0; i<count; i++) {
                const ix = i*3;
                positions[ix] = (Math.random()-0.5)*1000; positions[ix+1] = (Math.random()-0.5)*1000; positions[ix+2] = (Math.random()-0.5)*1000;
                targetPositions[ix] = positions[ix];
                targetPositions[ix+1] = positions[ix+1];
                targetPositions[ix+2] = positions[ix+2];
                sizes[i] = CONFIG.baseSize;
                targetSizes[i] = CONFIG.baseSize;
            }

            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1)); // å¢åŠ  size å±æ€§

            // ä½¿ç”¨ ShaderMaterial å®ç°è‡ªå®šä¹‰ç²’å­å¤§å°
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    pointTexture: { value: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png') }
                },
                vertexShader: `
                    attribute float size;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                        gl_PointSize = size * ( 300.0 / -mvPosition.z );
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D pointTexture;
                    varying vec3 vColor;
                    void main() {
                        gl_FragColor = vec4( vColor, 1.0 );
                        gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
                        if ( gl_FragColor.a < 0.1 ) discard;
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                vertexColors: true // ä¿®å¤ ERROR: 0:63: 'color' : undeclared identifier
            });

            particles = new THREE.Points(geometry, material); scene.add(particles);

            window.addEventListener('resize', onResize);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', () => { controls.autoRotate = false; isMouseDown = true; });
            document.addEventListener('mouseup', () => { isMouseDown = false; if (STATE.autoRotate && !STATE.handData.active) controls.autoRotate = true; });
            document.addEventListener('touchstart', onTouchStart, {passive: false});
            document.addEventListener('touchmove', onTouchMove, {passive: false});
            document.addEventListener('touchend', () => { isMouseDown = false; mouse.set(999,999); if (STATE.autoRotate && !STATE.handData.active) controls.autoRotate = true; });
            
            const dropZone = document.getElementById('dropZone');
            window.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.remove('hidden'); dropZone.classList.add('flex'); });
            window.addEventListener('dragleave', (e) => { if(e.relatedTarget === null) { dropZone.classList.add('hidden'); dropZone.classList.remove('flex'); } });
            window.addEventListener('drop', handleDrop);

            initStorages();
            loadStorage(0);
            
            animate();
        }

        // --- å‚¨è—å™¨é€»è¾‘ ---
        function initStorages() {
            const presets = [
                { type: 'terrain', color: '#00ffff', pSize: 1.5 },
                { type: 'sphere', color: '#ff00ff', pSize: 2.0 },
                { type: 'heart', color: '#ff4444', pSize: 2.5 },
                { type: 'saturn', color: '#ffff00', pSize: 1.8 },
                { type: 'text', data: 'AI', color: '#44ff44', pSize: 2.0 },
                { type: 'text', data: 'ZEN', color: '#ffffff', pSize: 2.0 }
            ];

            const container = document.getElementById('storageSlotsContainer');
            container.innerHTML = '';

            for(let i=1; i<=5; i++) {
                const p = presets[i];
                STATE.storages[i] = [{
                    id: 'preset_'+i,
                    type: p.type,
                    data: p.data || null,
                    x: 0, y: 0, scale: 1.0,
                    color: p.color,
                    pSize: p.pSize
                }];

                const row = document.createElement('div');
                row.className = 'flex items-center gap-2';
                row.innerHTML = `
                    <span class="text-xs font-mono w-4 text-gray-500">${i}</span>
                    <button class="storage-btn flex-1 py-2 bg-white/5 border border-white/10 rounded hover:bg-white/10 text-xs transition relative group" onclick="loadStorage(${i})" id="btn-storage-${i}">
                        å‚¨è—å™¨ ${i}
                        <div class="absolute right-2 top-1/2 -translate-y-1/2 opacity-0 group-hover:opacity-100">
                            <i class="fa-solid fa-play text-[10px]"></i>
                        </div>
                    </button>
                    <button class="w-8 h-8 flex items-center justify-center bg-white/5 hover:bg-cyan-500/20 rounded border border-white/10 text-xs text-gray-400 hover:text-cyan-400 transition" onclick="saveStorage(${i})" title="ä¿å­˜å½“å‰åˆ°Slot ${i}">
                        <i class="fa-solid fa-floppy-disk"></i>
                    </button>
                `;
                container.appendChild(row);
            }
            
            STATE.storages[0] = [{
                id: 'preset_0', type: 'terrain', x: 0, y: 0, scale: 1.0, color: '#00ffff', pSize: 1.2
            }];
        }

        function saveStorage(idx) {
            STATE.storages[idx] = JSON.parse(JSON.stringify(STATE.layers));
            const btn = idx === 0 ? document.querySelector(`button[onclick="loadStorage(0)"]`) : document.getElementById(`btn-storage-${idx}`);
            const originalText = btn.innerText;
            btn.innerText = "å·²ä¿å­˜!";
            setTimeout(() => btn.innerText = originalText, 1000);
        }

        function loadStorage(idx) {
            // å¦‚æœæ˜¯å‚¨è—æ¨¡å¼ï¼Œä¸” idx > 0ï¼Œæˆ‘ä»¬éœ€è¦æ··åˆ 0å·èƒŒæ™¯ + ç›®æ ‡æ§½ä½
            if (STATE.storageMode && idx > 0) {
                // ç¡®ä¿ 0 å·æ§½å­˜åœ¨
                const bgLayers = STATE.storages[0] ? JSON.parse(JSON.stringify(STATE.storages[0])) : [];
                const targetLayers = STATE.storages[idx] ? JSON.parse(JSON.stringify(STATE.storages[idx])) : [];
                STATE.layers = [...bgLayers, ...targetLayers];
            } else {
                // æ™®é€šæ¨¡å¼ æˆ– idx==0ï¼Œç›´æ¥åŠ è½½è¯¥æ§½ä½
                if (!STATE.storages[idx]) return;
                STATE.layers = JSON.parse(JSON.stringify(STATE.storages[idx]));
            }
            
            STATE.activeStorageIdx = idx;
            updateLayerListUI();
            recalculateScene();
            
            document.querySelectorAll('.storage-btn').forEach(b => b.classList.remove('active'));
            if(idx === 0) {
                document.querySelector(`button[onclick="loadStorage(0)"]`).classList.add('active');
            } else {
                const b = document.getElementById(`btn-storage-${idx}`);
                if(b) b.classList.add('active');
            }
        }

        const storageModeToggle = document.getElementById('storageModeToggle');
        const gestureStatusPanel = document.getElementById('gestureStatusPanel');
        
        storageModeToggle.addEventListener('change', (e) => {
            STATE.storageMode = e.target.checked;
            if(STATE.storageMode) {
                gestureStatusPanel.classList.remove('hidden');
                document.getElementById('gestureScaleBtn').parentElement.classList.add('opacity-50', 'pointer-events-none');
                // åˆ‡æ¢åˆ°å½“å‰æ¿€æ´»çš„æ¨¡å¼ï¼ˆè§¦å‘åˆå¹¶é€»è¾‘ï¼‰
                loadStorage(STATE.activeStorageIdx);
            } else {
                gestureStatusPanel.classList.add('hidden');
                document.getElementById('gestureScaleBtn').parentElement.classList.remove('opacity-50', 'pointer-events-none');
                // æ¢å¤æ™®é€šæ¨¡å¼ï¼ˆè§¦å‘å•ä¸€åŠ è½½é€»è¾‘ï¼‰
                loadStorage(STATE.activeStorageIdx);
            }
        });


        // --- ç”Ÿæˆå™¨é€»è¾‘ ---
        const Generators = {
            sphere: (cnt) => { const pts=[]; for(let i=0;i<cnt;i++){ const t=Math.random()*Math.PI*2,p=Math.acos(2*Math.random()-1),r=60; pts.push(r*Math.sin(p)*Math.cos(t),r*Math.sin(p)*Math.sin(t),r*Math.cos(p)); } return pts; },
            heart: (cnt) => { const pts=[]; for(let i=0;i<cnt;i++){ const t=Math.random()*Math.PI*2,s=3.5*Math.sqrt(Math.random()); pts.push((16*Math.pow(Math.sin(t),3))*s,(13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t))*s,(Math.random()-0.5)*15); } return pts; },
            terrain: (cnt) => {
                const pts=[]; const size=1200;
                for(let i=0;i<cnt;i++){
                    const x=(Math.random()-0.5)*size, z=(Math.random()-0.5)*size;
                    let h=0;
                    h+=120*Math.sin(x*0.012)*Math.cos(z*0.012); h+=70*Math.sin(x*0.03+z*0.02)*Math.cos(x*0.03); h+=50*Math.pow(Math.abs(Math.sin(x*0.02)*Math.cos(z*0.02)),2); h+=10*Math.cos(x*0.1)*Math.sin(z*0.1); h+=5*(Math.random()-0.5);
                    if(h>0)h*=1.8;
                    const rx=250*Math.sin(z*0.005)+80*Math.cos(z*0.015), rw=40+15*Math.sin(z*0.02), d=Math.abs(x-rx);
                    let r=-1,g=-1,b=-1;
                    if(d<rw){ h=-50+Math.random()*2; r=0;g=0.7;b=1; } else { if(d<rw+60){const t=(d-rw)/60; if(h>-40)h=-40+(h+40)*t*t;} if(h<-50){const w=4*Math.sin(x*0.1)+4*Math.cos(z*0.1);h=-50+w+Math.random()*2; r=0.05;g=0.2;b=0.6;} }
                    pts.push(x,h,z,r,g,b);
                } return pts;
            },
            saturn: (cnt) => { const pts=[]; const pc=Math.floor(cnt*0.6); for(let i=0;i<cnt;i++){ if(i<pc){const t=Math.random()*Math.PI*2,p=Math.acos(2*Math.random()-1),r=35;pts.push(r*Math.sin(p)*Math.cos(t),r*Math.sin(p)*Math.sin(t),r*Math.cos(p));}else{const a=Math.random()*Math.PI*2,r=50+Math.random()*35;pts.push(r*Math.cos(a),(Math.random()-0.5)*2,r*Math.sin(a));} } return pts; },
            text: (cnt,txt) => processImageOrText('text',txt,cnt),
            image: (cnt,img) => processImageOrText('image',img,cnt)
        };

        function processImageOrText(t,d,cnt){
            const c=document.createElement('canvas'),x=c.getContext('2d');
            c.width=CONFIG.canvasW;c.height=CONFIG.canvasH;
            x.fillStyle='#000';x.fillRect(0,0,c.width,c.height);
            if(t==='text'){x.font='bold 150px Inter';x.fillStyle='#fff';x.textAlign='center';x.textBaseline='middle';x.fillText(d,c.width/2,c.height/2);}
            else{const a=d.width/d.height;let dw=c.width,dh=c.width/a;if(dh>c.height){dh=c.height;dw=dh*a;}x.drawImage(d,(c.width-dw)/2,(c.height-dh)/2,dw,dh);}
            const id=x.getImageData(0,0,c.width,c.height).data, v=[], step=2;
            for(let y=0;y<c.height;y+=step)for(let xx=0;xx<c.width;xx+=step){const i=(y*c.width+xx)*4;if(id[i]+id[i+1]+id[i+2]>50)v.push({x:(xx-c.width/2)*0.5,y:-(y-c.height/2)*0.5,c:[id[i]/255,id[i+1]/255,id[i+2]/255]});}
            const pts=[]; if(v.length>0){for(let i=0;i<cnt;i++){const p=v[Math.floor(i*v.length/cnt)%v.length];pts.push(p.x+(Math.random()-0.5)*2,p.y+(Math.random()-0.5)*2,(Math.random()-0.5)*5,t==='image'?p.c[0]:-1,t==='image'?p.c[1]:-1,t==='image'?p.c[2]:-1);}}else{for(let i=0;i<cnt;i++)pts.push(0,0,0,-1,-1,-1);}
            return pts;
        }

        // --- æ ¸å¿ƒæ›´æ–°é€»è¾‘ ---
        function addLayer(type, data=null) {
            const id=Date.now().toString()+Math.random().toString(16).slice(2);
            const cs=['#00ffff','#ff00ff','#ffff00','#ff4444','#44ff44'];
            STATE.layers.push({id,type,data,x:0,y:0,scale:1.0,color:cs[Math.floor(Math.random()*cs.length)], pSize: 1.5});
            updateLayerListUI(); recalculateScene();
        }
        function removeLayer(id){ STATE.layers=STATE.layers.filter(l=>l.id!==id); updateLayerListUI(); recalculateScene(); }
        function updateLayer(id,k,v){ const l=STATE.layers.find(l=>l.id===id); if(l){l[k]=v;recalculateScene();} }

        function recalculateScene() {
            if(STATE.layers.length===0){ for(let i=0;i<CONFIG.maxParticles*3;i++) targetPositions[i]=9999; return; }
            const ppl=Math.floor(CONFIG.maxParticles/STATE.layers.length);
            let idx=0;
            STATE.layers.forEach(l=>{
                let pts=(l.type==='text'||l.type==='image')?Generators[l.type](ppl,l.data):Generators[l.type](ppl);
                const c=new THREE.Color(l.color);
                const layerPSize = l.pSize || 1.5; // è·å–å›¾å±‚ç²’å­å¤§å°
                
                for(let i=0;i<ppl;i++){
                    const k=(idx+i)*3;
                    const ki = idx+i;
                    let x,y,z,r=-1,g,b;
                    if(l.type==='image'||l.type==='text'||l.type==='terrain'){ x=pts[i*6];y=pts[i*6+1];z=pts[i*6+2];r=pts[i*6+3];g=pts[i*6+4];b=pts[i*6+5]; }
                    else{ x=pts[i*3];y=pts[i*3+1];z=pts[i*3+2]; }
                    
                    targetPositions[k]=x*l.scale+l.x*50; targetPositions[k+1]=y*l.scale+l.y*50; targetPositions[k+2]=z*l.scale;
                    targetSizes[ki] = layerPSize; // è®¾ç½®ç›®æ ‡å¤§å°

                    if(r!==-1){ targetColors[k]=r;targetColors[k+1]=g;targetColors[k+2]=b; }
                    else{ targetColors[k]=c.r;targetColors[k+1]=c.g;targetColors[k+2]=c.b; }
                }
                idx+=ppl;
            });
            for(let i=idx*3;i<CONFIG.maxParticles*3;i++) targetPositions[i]=9999;
        }

        function updateLayerListUI() {
            const el=document.getElementById('layersList'); el.innerHTML='';
            STATE.layers.forEach(l=>{
                const d=document.createElement('div');
                d.className='bg-white/5 border border-white/5 p-3 rounded-xl flex flex-col gap-2 hover:bg-white/10 transition';
                let icon='ğŸ”®',lbl='çƒä½“';
                if(l.type==='heart'){icon='â¤ï¸';lbl='çˆ±å¿ƒ';} if(l.type==='saturn'){icon='ğŸª';lbl='åœŸæ˜Ÿ';} if(l.type==='terrain'){icon='ğŸ”ï¸';lbl='ä¸‡æ°´åƒå±±';} if(l.type==='text'){icon='ğŸ”¤';lbl=l.data;} if(l.type==='image'){icon='ğŸ–¼ï¸';lbl='Img';}
                d.innerHTML=`
                    <div class="flex justify-between items-center pb-2 border-b border-white/5">
                        <div class="flex items-center gap-2">
                            <span class="text-lg">${icon}</span>
                            <span class="text-xs font-bold text-gray-200 truncate max-w-[80px]">${lbl}</span>
                            <div class="color-picker-wrapper w-5 h-5 ml-1" style="background-color:${l.color}"><input type="color" value="${l.color}" oninput="updateLayer('${l.id}','color',this.value);this.parentElement.style.backgroundColor=this.value;"></div>
                        </div>
                        <button class="text-red-400 w-6 h-6 rounded-full hover:bg-red-500/20 transition" onclick="removeLayer('${l.id}')"><i class="fa-solid fa-times text-sm"></i></button>
                    </div>
                    <div class="grid grid-cols-2 gap-2 mt-1">
                        <div class="flex items-center gap-2 text-[10px] text-gray-400"><span class="font-mono w-4 text-center">X</span><input type="range" class="flex-1" min="-4" max="4" step="0.1" value="${l.x}" oninput="updateLayer('${l.id}','x',parseFloat(this.value))"></div>
                        <div class="flex items-center gap-2 text-[10px] text-gray-400"><span class="font-mono w-4 text-center">Y</span><input type="range" class="flex-1" min="-2" max="2" step="0.1" value="${l.y}" oninput="updateLayer('${l.id}','y',parseFloat(this.value))"></div>
                        <div class="flex items-center gap-2 text-[10px] text-gray-400"><span class="font-mono w-4 text-center">S</span><input type="range" class="flex-1" min="0.1" max="7.0" step="0.1" value="${l.scale}" oninput="updateLayer('${l.id}','scale',parseFloat(this.value))"></div>
                        <div class="flex items-center gap-2 text-[10px] text-gray-400"><span class="font-mono w-4 text-center">P</span><input type="range" class="flex-1" min="0.5" max="5.0" step="0.1" value="${l.pSize || 1.5}" oninput="updateLayer('${l.id}','pSize',parseFloat(this.value))"></div>
                    </div>`;
                el.appendChild(d);
            });
        }

        // --- MediaPipe æ‰‹åŠ¿é€»è¾‘ ---
        const videoElement=document.getElementById('videoInput'), canvasElement=document.getElementById('camOutput'), canvasCtx=canvasElement.getContext('2d');
        const hands=new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({maxNumHands:2,modelComplexity:1,minDetectionConfidence:0.5,minTrackingConfidence:0.5});
        
        hands.onResults(res=>{
            canvasCtx.save(); canvasCtx.clearRect(0,0,canvasElement.width,canvasElement.height); canvasCtx.fillStyle='rgba(0,0,0,0.5)'; canvasCtx.fillRect(0,0,canvasElement.width,canvasElement.height);
            STATE.handData.active=false;
            STATE.handData.rightFingers = 0; // Reset
            
            let storageHandDetected = false; 
            
            if(res.multiHandLandmarks && res.multiHandLandmarks.length>0){
                STATE.handData.active=true;
                
                // éå†æ£€æµ‹åˆ°çš„æ‰‹
                for(let i=0; i<res.multiHandLandmarks.length; i++){
                    const lm = res.multiHandLandmarks[i];
                    const classification = res.multiHandedness[i];
                    const isRightHand = classification.label === 'Right'; 
                    
                    drawConnectors(canvasCtx, lm, HAND_CONNECTIONS, {color: isRightHand?'#00ffff':'#ff00ff', lineWidth:2});
                    drawLandmarks(canvasCtx, lm, {color:'#ff0000', lineWidth:1, radius:3});

                    if (STATE.storageMode) {
                        // === å‚¨è—æ¨¡å¼é€»è¾‘ ===
                        if (!isRightHand) { 
                            storageHandDetected = true;
                            // è®¡æ•°ä¼¸å‡ºçš„æ‰‹æŒ‡ (å·¦æ‰‹)
                            let count = 0;
                            // æ‹‡æŒ‡åˆ¤å®š: å·¦æ‰‹æ‰‹å¿ƒå‘è‡ªå·±æ—¶ï¼Œæ‹‡æŒ‡x > æŒ‡æ ¹x
                            if (lm[4].x > lm[3].x) count++;
                            if (lm[8].y < lm[6].y) count++;
                            if (lm[12].y < lm[10].y) count++;
                            if (lm[16].y < lm[14].y) count++;
                            if (lm[20].y < lm[18].y) count++;
                            
                            const indexUp = lm[8].y < lm[6].y;
                            const middleUp = lm[12].y < lm[10].y;
                            const ringUp = lm[16].y < lm[14].y;
                            const pinkyUp = lm[20].y < lm[18].y;
                            const thumbUp = lm[4].x > lm[3].x;

                            // æ˜ å°„æ‰‹åŠ¿åˆ° 1-5
                            let slot = 0;
                            if (indexUp && !middleUp && !ringUp && !pinkyUp) slot = 1;
                            else if (indexUp && middleUp && !ringUp && !pinkyUp) slot = 2;
                            else if (indexUp && middleUp && ringUp && !pinkyUp) slot = 3;
                            else if (indexUp && middleUp && ringUp && pinkyUp && !thumbUp) slot = 4;
                            else if (indexUp && middleUp && ringUp && pinkyUp && thumbUp) slot = 5;
                            if (count === 5) slot = 5;

                            document.getElementById('leftHandStatus').innerText = slot > 0 ? `åŠ è½½ ${slot}` : "èƒŒæ™¯ (0)";
                            
                            if (slot !== STATE.activeStorageIdx) {
                                loadStorage(slot);
                            }

                        } else {
                            // Right Hand: Scale Control
                            const d = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                            const scaleFactor = 0.5 + (d / 0.2) * 4.0;
                            STATE.handData.targetScale = scaleFactor;
                            document.getElementById('rightHandStatus').innerText = `ç¼©æ”¾ ${(scaleFactor).toFixed(1)}x`;
                        }
                    } else {
                        // === æ ‡å‡†æ¨¡å¼é€»è¾‘ ===
                        const d4_8 = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                        const d8_12 = Math.hypot(lm[8].x - lm[12].x, lm[8].y - lm[12].y);
                        const d4_12 = Math.hypot(lm[4].x - lm[12].x, lm[4].y - lm[12].y);
                        const isThreeFingers = (d4_8 < 0.08 && d8_12 < 0.08 && d4_12 < 0.1);
                        if(isThreeFingers){ STATE.handData.mode='rotate'; STATE.handData.x=(1-lm[9].x)*2-1; STATE.handData.y=-(lm[9].y*2-1); }
                        else{ STATE.handData.mode='scale'; STATE.handData.pinchDist=d4_8; STATE.handData.y=lm[9].y; }
                    }
                }
            } else {
                if(STATE.autoRotate && !isMouseDown) controls.autoRotate=true;
                
                // å‚¨è—æ¨¡å¼ä¸‹æ— å·¦æ‰‹ï¼šå›é€€åˆ°0å·
                if (STATE.storageMode && !storageHandDetected && STATE.activeStorageIdx !== 0) {
                    loadStorage(0);
                    document.getElementById('leftHandStatus').innerText = "èƒŒæ™¯ (0)";
                }
            }
            canvasCtx.restore();
        });

        const cameraUtils = new Camera(videoElement, {onFrame: async () => { await hands.send({image: videoElement}); }, width: 320, height: 240, facingMode: 'user'});
        document.getElementById('toggleCamBtn').addEventListener('click', () => {
            if(!STATE.isCamActive){ cameraUtils.start().then(()=>{ STATE.isCamActive=true; document.getElementById('camContainer').classList.remove('hidden'); }); }
            else{ cameraUtils.stop(); STATE.isCamActive=false; document.getElementById('camContainer').classList.add('hidden'); }
        });

        // æŒ‰é’®ç»‘å®š
        function updateGestureBtn(id,k){const b=document.getElementById(id);b.addEventListener('click',()=>{STATE.gestures[k]=!STATE.gestures[k]; b.className=STATE.gestures[k]?'toggle-active border p-2 rounded-lg flex flex-col items-center gap-1 transition active:scale-95':'toggle-inactive border p-2 rounded-lg flex flex-col items-center gap-1 transition active:scale-95';});}
        updateGestureBtn('gestureScaleBtn','scale'); updateGestureBtn('gestureRotateBtn','rotate'); updateGestureBtn('gestureFlattenBtn','flatten');

        // åŠ¨ç”»
        function animate() {
            requestAnimationFrame(animate); controls.update();
            const time=Date.now()*0.001, globalForce=parseFloat(document.getElementById('forceRange').value);
            let ix,iy,force=0;

            if(STATE.isCamActive && STATE.handData.active) {
                if (STATE.storageMode) {
                    if (STATE.handData.targetScale) {
                        scene.scale.setScalar(THREE.MathUtils.lerp(scene.scale.x, STATE.handData.targetScale, 0.1));
                    }
                    controls.autoRotate = false;
                } else {
                    // æ ‡å‡†æ¨¡å¼
                    if(STATE.handData.mode==='rotate' && STATE.gestures.rotate){
                        scene.rotation.y += (STATE.handData.x*Math.PI - scene.rotation.y)*0.1;
                        scene.rotation.x += (STATE.handData.y*Math.PI*0.5 - scene.rotation.x)*0.1;
                    } else {
                        let ns=scene.scale.x;
                        if(STATE.gestures.scale){ const d=STATE.handData.pinchDist, norm=Math.max(0,Math.min(1,(d-0.02)/0.25)); ns=THREE.MathUtils.lerp(scene.scale.x, 0.5+norm*3.5, 0.1); }
                        let fs=1.0;
                        if(STATE.gestures.flatten){ const hy=Math.max(0,Math.min(1,STATE.handData.y)); if(hy>0.1) fs=Math.max(0.1, 1.0-((hy-0.1)/0.8)*0.9); }
                        scene.scale.set(ns, ns*fs, ns);
                        if(STATE.gestures.scale||STATE.gestures.rotate) scene.rotation.x += (0-scene.rotation.x)*0.05;
                    }
                    controls.autoRotate = false;
                }
            } else {
                const vec=new THREE.Vector3(mouse.x,mouse.y,0.5); vec.unproject(camera);
                const dir=vec.sub(camera.position).normalize(), dist=-camera.position.z/dir.z, pos=camera.position.clone().add(dir.multiplyScalar(dist));
                ix=pos.x; iy=pos.y;
                if(mouse.x!==999) force=(isMouseDown&&!isDragging)?3.0*globalForce:0.8*globalForce;
                if(!isDragging && !STATE.storageMode) scene.scale.y = THREE.MathUtils.lerp(scene.scale.y, scene.scale.x, 0.1);
            }

            const posArr=geometry.attributes.position.array, colArr=geometry.attributes.color.array, sizeArr=geometry.attributes.size.array;
            for(let i=0;i<CONFIG.maxParticles;i++){
                const k=i*3;
                if(targetPositions[k]>5000){ posArr[k]=9999; continue; }
                posArr[k]+=(targetPositions[k]-posArr[k])*0.06; posArr[k+1]+=(targetPositions[k+1]-posArr[k+1])*0.06; posArr[k+2]+=(targetPositions[k+2]-posArr[k+2])*0.06;
                colArr[k]+=(targetColors[k]-colArr[k])*0.1; colArr[k+1]+=(targetColors[k+1]-colArr[k+1])*0.1; colArr[k+2]+=(targetColors[k+2]-colArr[k+2])*0.1;
                sizeArr[i]+=(targetSizes[i]-sizeArr[i])*0.1; // ç²’å­å¤§å°ç¼“åŠ¨

                if(!STATE.storageMode && STATE.handData.mode!=='rotate'){
                    const dx=posArr[k]-ix, dy=posArr[k+1]-iy, d=Math.sqrt(dx*dx+dy*dy);
                    if(d<70 && force!==0){ const a=Math.atan2(dy,dx), p=force*((70-d)/70)*10; posArr[k]+=Math.cos(a)*p; posArr[k+1]+=Math.sin(a)*p; }
                }
                posArr[k+1]+=Math.sin(time*1.5+posArr[k]*0.02)*0.08;
            }
            geometry.attributes.position.needsUpdate=true; geometry.attributes.color.needsUpdate=true; geometry.attributes.size.needsUpdate=true;
            renderer.render(scene, camera);
        }

        // Mouse/Touch Handlers
        function onMouseMove(e){ mouse.x=(e.clientX/window.innerWidth)*2-1; mouse.y=-(e.clientY/window.innerHeight)*2+1; }
        function onTouchStart(e){ if(e.target.tagName==='CANVAS'&&e.target.id!=='camOutput'){ isMouseDown=true; if(e.touches.length===1){ mouse.x=(e.touches[0].clientX/window.innerWidth)*2-1; mouse.y=-(e.touches[0].clientY/window.innerHeight)*2+1; } } }
        function onTouchMove(e){ if(e.target.tagName==='CANVAS'&&e.target.id!=='camOutput'){ if(e.touches.length===1){ mouse.x=(e.touches[0].clientX/window.innerWidth)*2-1; mouse.y=-(e.touches[0].clientY/window.innerHeight)*2+1; } } }
        function onResize(){ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); }
        function handleDrop(e){ e.preventDefault(); document.getElementById('dropZone').classList.add('hidden'); document.getElementById('dropZone').classList.remove('flex'); const f=e.dataTransfer.files[0]; if(f&&f.type.startsWith('image/')){ const r=new FileReader(); r.onload=(ev)=>{ const i=new Image(); i.onload=()=>addLayer('image',i); i.src=ev.target.result; }; r.readAsDataURL(f); } }

        // Buttons
        document.querySelectorAll('.add-shape-btn').forEach(b=>b.addEventListener('click',()=>{ if(b.dataset.type==='text') document.getElementById('textModal').classList.remove('hidden'); else addLayer(b.dataset.type); }));
        document.getElementById('confirmTextBtn').addEventListener('click',()=>{ addLayer('text',document.getElementById('modalTextInput').value||"AI"); document.getElementById('textModal').classList.add('hidden'); });
        document.getElementById('cancelTextBtn').addEventListener('click',()=>document.getElementById('textModal').classList.add('hidden'));
        document.getElementById('clearAllBtn').addEventListener('click',()=>{ STATE.layers=[]; updateLayerListUI(); recalculateScene(); });
        document.getElementById('resetViewBtn').addEventListener('click',()=>{ controls.reset(); scene.scale.setScalar(1); });
        // remove old global sizeRange listener if exists, or just leave it since we removed the element from HTML
        document.getElementById('forceRange').addEventListener('input',(e)=>{ document.getElementById('forceVal').innerText=e.target.value; });
        document.getElementById('toggleRotateBtn').addEventListener('click',()=>{ STATE.autoRotate=!STATE.autoRotate; controls.autoRotate=STATE.autoRotate; });

        initThree();
    </script>
</body>
</html>